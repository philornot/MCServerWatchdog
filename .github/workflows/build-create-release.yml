name: Build, Test, Release and Deploy

# Konfiguracja uprawnie≈Ñ - niezbƒôdna do aktualizacji repozytorium i publikowania pakiet√≥w
permissions:
  contents: write  # Uprawnienia do pushowania zmian i tworzenia release'√≥w
  packages: write  # Uprawnienia do publikowania obraz√≥w Docker

# Wyzwalacze workflow
on:
  # Uruchamianie przy push do g≈Ç√≥wnej ga≈Çƒôzi - u≈ºywamy dynamicznego wykrywania nazwy
  push:
    branches:
      - 'master'  # G≈Ç√≥wna ga≈ÇƒÖ≈∫, zmie≈Ñ je≈õli u≈ºywasz innej nazwy
      - 'main'    # Alternatywna popularna nazwa

  # Uruchamianie rƒôczne z wyborem typu wersji
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Typ wydania'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch   # Drobne poprawki (zwiƒôksza 0.0.X)
          - minor   # Nowe funkcje (zwiƒôksza 0.X.0)
          - major   # Zmiany ≈ÇamiƒÖce kompatybilno≈õƒá (zwiƒôksza X.0.0)

# Definicja zada≈Ñ
jobs:
  build-test-release:
    runs-on: ubuntu-latest

    steps:
      # Krok 1: Pobierz kod
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Pobierz pe≈ÇnƒÖ historiƒô (potrzebne dla tag√≥w i historii commit√≥w)

      # Krok 2: Wykryj nazwƒô bie≈ºƒÖcej ga≈Çƒôzi i zapisz jƒÖ jako zmiennƒÖ
      - name: Get current branch
        id: branch
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "Current branch name: $BRANCH_NAME"
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      # Krok 3: Konfiguracja Pythona
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Krok 4: Instalacja zale≈ºno≈õci
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest semver
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # Krok 5: Lintowanie kodu (sprawdzanie b≈Çƒôd√≥w sk≈Çadniowych)
      - name: Lint with flake8
        id: lint
        continue-on-error: true  # Nie zatrzymuj workflow w przypadku b≈Çƒôd√≥w lintowania
        run: |
          # Sprawdzenie tylko krytycznych b≈Çƒôd√≥w
          LINT_OUTPUT=$(flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics)
          echo "::warning::$LINT_OUTPUT"
          
          # Zapisz czy wystƒÖpi≈Çy b≈Çƒôdy
          if [ -n "$LINT_OUTPUT" ]; then
            echo "Znaleziono problemy w kodzie, sprawd≈∫ szczeg√≥≈Çy w logach"
            echo "has_errors=true" >> $GITHUB_OUTPUT
          else
            echo "Analiza kodu przebieg≈Ça pomy≈õlnie"
            echo "has_errors=false" >> $GITHUB_OUTPUT
          fi

      # Krok 6: Generowanie i walidacja wersji
      - name: Generate and Validate Version
        id: version
        run: |
          # Funkcja do inkrementacji wersji w zale≈ºno≈õci od podanego typu wydania
          increment_version() {
            local version=$1
            local type=$2
      
            # Sprawd≈∫, czy wersja jest w poprawnym formacie SemVer (np. 1.0.0)
            if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Niepoprawny format wersji w pliku version.txt lub brak poprawnej wersji. Ustawiam domy≈õlnƒÖ wersjƒô 1.0.0."
              version="1.0.0"
            fi
      
            # Rozdziel wersjƒô na czƒô≈õci: major, minor, patch
            IFS='.' read -r major minor patch <<< "$version"
      
            # Inkrementuj odpowiedniƒÖ czƒô≈õƒá wersji w zale≈ºno≈õci od typu wydania
            case $type in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch|*)  # Domy≈õlnie inkrementuj patch (np. 0.0.X)
                patch=$((patch + 1))
                ;;
            esac
      
            # Zwr√≥ƒá nowƒÖ wersjƒô
            echo "$major.$minor.$patch"
          }
      
          # Pobierz typ wydania (major, minor, patch) z wej≈õcia workflow
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          RELEASE_TYPE=${RELEASE_TYPE:-patch}  # Domy≈õlnie ustaw patch, je≈õli brak warto≈õci
      
          # Odczytaj wersjƒô z pliku version.txt, je≈õli istnieje
          if [ -f "version.txt" ]; then
            VERSION=$(cat version.txt | tr -d '[:space:]')  # Usu≈Ñ bia≈Çe znaki
          else
            VERSION="1.0.0"  # Ustaw domy≈õlnƒÖ wersjƒô, je≈õli plik nie istnieje
          fi
      
          # Wygeneruj nowƒÖ wersjƒô z inkrementacjƒÖ
          NEW_VERSION=$(increment_version "$VERSION" "$RELEASE_TYPE")
      
          # Walidacja wygenerowanej wersji
          if [[ ! "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "B≈ÇƒÖd: Wygenerowana wersja '$NEW_VERSION' jest nieprawid≈Çowa."
            exit 1
          fi
      
          # Wyprowad≈∫ poprawnƒÖ wersjƒô do pliku version.txt i outputs
          echo "clean_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "$NEW_VERSION" > version.txt
          echo "Wygenerowana wersja: $NEW_VERSION"

      # Krok 7: Commitowanie zmian w pliku version.txt
      - name: Commit version file
        id: commit
        run: |
          # Pobierz nazwƒô bie≈ºƒÖcej ga≈Çƒôzi z poprzedniego kroku
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          echo "Bie≈ºƒÖca ga≈ÇƒÖ≈∫: $BRANCH_NAME"
          
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Sprawd≈∫, czy plik version.txt zosta≈Ç zmieniony
          if [[ -n "$(git status --porcelain version.txt)" ]]; then
            echo "Plik version.txt zosta≈Ç zmieniony, tworzƒô commit..."
            
            # Dodaj plik version.txt do stage
            git add version.txt
            
            # Utw√≥rz commit
            git commit -m "Aktualizacja version.txt do wersji ${{ steps.version.outputs.VERSION }}"
            
            # Wypchnij zmiany do repozytorium
            echo "Wypychanie zmian do ga≈Çƒôzi $BRANCH_NAME..."
            git push origin HEAD:${BRANCH_NAME}
            
            echo "Zaktualizowano plik version.txt w repozytorium"
            echo "committed=true" >> $GITHUB_OUTPUT
          else
            echo "Plik version.txt nie uleg≈Ç zmianie, pomijam commit"
            echo "committed=false" >> $GITHUB_OUTPUT
          fi

      # Krok 8: Generowanie changelog
      - name: Generate changelog
        id: changelog
        run: |
          # U≈ºyj odpowiedniego punktu odniesienia do wyszukiwania commit√≥w
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            echo "Poprzedni commit zawiera≈Ç aktualizacjƒô version.txt, uwzglƒôdniam w changelog"
            # U≈ºyj HEAD~1 jako bazy, aby uwzglƒôdniƒá ostatni commit aktualizujƒÖcy wersjƒô
            GIT_REF_BASE="HEAD~1"
          else
            echo "Poprzedni commit nie zawiera≈Ç aktualizacji version.txt"
            GIT_REF_BASE="HEAD"
          fi
          
          # Pobierz commity od ostatniego taga lub poczƒÖtku historii
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "Nie znaleziono tag√≥w, pobieram wszystkie commity (maksymalnie 20)"
            # Je≈õli nie ma tag√≥w, we≈∫ wszystkie commity (ale ogranicz do 20)
            COMMIT_LIST=$(git log --pretty=format:"%h||%an||%s" --reverse | tail -n 20)
          else
            echo "Znaleziono tag $LAST_TAG, pobieram commity od tego tagu"
            # Je≈õli sƒÖ tagi, we≈∫ commity od ostatniego taga
            COMMIT_LIST=$(git log ${LAST_TAG}..${GIT_REF_BASE} --pretty=format:"%h||%an||%s" --reverse)
          fi
          
          # Przygotuj mapƒô kategorii zmian - u≈ºywamy zwyk≈Çych identyfikator√≥w jako kluczy
          declare -A CATEGORIES
          CATEGORIES=(
            ["fix"]="Poprawki b≈Çƒôd√≥w"
            ["feat"]="Nowe funkcje"
            ["docs"]="Dokumentacja"
            ["style"]="Formatowanie kodu"
            ["refactor"]="Refaktoryzacja"
            ["perf"]="Optymalizacja"
            ["test"]="Testy"
            ["build"]="Build"
            ["ci"]="CI/CD"
            ["chore"]="PorzƒÖdki"
          )
          
          # Mapa emoji dla ka≈ºdej kategorii - u≈ºywana tylko do wy≈õwietlania
          declare -A CATEGORY_EMOJIS
          CATEGORY_EMOJIS=(
            ["fix"]="üêõ"
            ["feat"]="‚ú®"
            ["docs"]="üìö"
            ["style"]="üíé"
            ["refactor"]="‚ôªÔ∏è"
            ["perf"]="üöÄ"
            ["test"]="üß™"
            ["build"]="üîß"
            ["ci"]="ü§ñ"
            ["chore"]="üßπ"
            ["other"]="üîÑ"
          )
          
          # Funkcja sprawdzajƒÖca typ commita
          get_commit_type() {
            local commit_msg="$1"
            
            for type in "${!CATEGORIES[@]}"; do
              if [[ "$commit_msg" == "$type"* || "$commit_msg" == *"[$type]"* || "$commit_msg" == *"($type)"* ]]; then
                echo "$type"
                return
              fi
            done
            
            # Domy≈õlnie, je≈õli nie rozpoznano typu
            echo "other"
          }
          
          # Inicjalizacja zmiennych dla ka≈ºdej kategorii - u≈ºywamy bezpiecznych identyfikator√≥w
          for type in "${!CATEGORIES[@]}"; do
            eval "${type}_commits=''"
          done
          other_commits=""
          
          # Sprawd≈∫, czy lista commit√≥w jest pusta
          if [ -z "$COMMIT_LIST" ]; then
            echo "Nie znaleziono ≈ºadnych commit√≥w od ostatniego tagu"
          else 
            echo "Znaleziono commity, przetwarzam..."
            
            # Przetwarzanie commit√≥w i grupowanie ich
            while IFS= read -r line; do
              if [ -z "$line" ]; then
                continue
              fi
              
              # Parsuj liniƒô na hash, autora i wiadomo≈õƒá, zabezpieczajƒÖc przed specjalnymi znakami
              IFS='||' read -r hash author message <<< "$line"
              
              if [ -z "$hash" ] || [ -z "$message" ]; then
                echo "Pominiƒôto niew≈Ça≈õciwy format commita: $line"
                continue
              fi
              
              # Okre≈õl typ commita
              commit_type=$(get_commit_type "$message")
              
              # Usu≈Ñ prefix typu z tre≈õci commita, z dodatkowym zabezpieczeniem przed b≈Çƒôdami
              clean_message=$(echo "$message" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\([^)]+\))?:\s*//g' | sed -E 's/\[(feat|fix|docs|style|refactor|perf|test|build|ci|chore)\]\s*//g' | sed -E 's/\((feat|fix|docs|style|refactor|perf|test|build|ci|chore)\)\s*//g')
              
              # Zabezpiecz tekst przed specjalnymi znakami w bash
              clean_message=$(echo "$clean_message" | sed 's/"/\\"/g')
              
              # ≈Åadne formatowanie wpisu changelog z linkiem do commita
              formatted_entry="* ${clean_message} [${hash}](https://github.com/${{ github.repository }}/commit/${hash})"
              
              # Dodaj do odpowiedniej kategorii
              if [ "$commit_type" != "other" ]; then
                # U≈ºywamy zmiennej z bezpiecznƒÖ nazwƒÖ
                eval "${commit_type}_commits=\"\${${commit_type}_commits}\n${formatted_entry}\""
              else
                other_commits="${other_commits}\n${formatted_entry}"
              fi
            done <<< "$COMMIT_LIST"
          fi
          
          # Przygotowanie ka≈ºdej sekcji
          FINAL_CHANGELOG=""
          
          # Dodaj sekcje tylko je≈õli majƒÖ zawarto≈õƒá
          for type in "${!CATEGORIES[@]}"; do
            # Pobierz zawarto≈õƒá z bezpiecznej zmiennej
            eval "commits=\${${type}_commits}"
            
            if [ -n "$commits" ]; then
              emoji="${CATEGORY_EMOJIS[$type]}"
              category_name="${CATEGORIES[$type]}"
              FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} ${category_name}\n${commits}\n\n"
            fi
          done
          
          # Dodaj inne zmiany (je≈õli sƒÖ)
          if [ -n "$other_commits" ]; then
            emoji="${CATEGORY_EMOJIS[other]}"
            FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} Inne zmiany${other_commits}\n\n"
          fi
          
          # Je≈õli nie ma zmian, dodaj informacjƒô
          if [ -z "$FINAL_CHANGELOG" ]; then
            FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
          fi
          
          # Zapisz changelog do pliku
          echo "# üì¶ MCServerWatchdog v${{ steps.version.outputs.VERSION }}" > changelog.md
          echo "" >> changelog.md
          echo "Data wydania: $(date +'%d.%m.%Y')" >> changelog.md
          echo "" >> changelog.md
          echo -e "## üìã Lista zmian\n" >> changelog.md
          echo -e "$FINAL_CHANGELOG" >> changelog.md
          echo "## üìä Statystyki" >> changelog.md
          echo "- Wersja: ${{ steps.version.outputs.VERSION }}" >> changelog.md
          
          # Liczba commit√≥w
          if [ -n "$COMMIT_LIST" ]; then
            COMMIT_COUNT=$(echo "$COMMIT_LIST" | wc -l)
            echo "- Liczba commit√≥w: $COMMIT_COUNT" >> changelog.md
            
            # Lista autor√≥w
            AUTHORS=$(echo "$COMMIT_LIST" | cut -d'||' -f2 | sort | uniq | tr '\n' ', ' | sed 's/,\s*$//')
            if [ -n "$AUTHORS" ]; then
              echo "- Autorzy: $AUTHORS" >> changelog.md
            else
              echo "- Autorzy: Nieznani" >> changelog.md
            fi
          else
            echo "- Liczba commit√≥w: 0" >> changelog.md
            echo "- Autorzy: Brak nowych commit√≥w" >> changelog.md
          fi
          
          # Zapisz changelog jako output
          # U≈ºyj heredoc formatu dla zachowania znak√≥w nowej linii
          echo 'CHANGELOG<<EOF' >> $GITHUB_OUTPUT
          cat changelog.md >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

      # Krok 9: Przygotowanie tag√≥w Docker (zastƒÖpienie + na -)
      - name: Prepare Docker tags
        id: docker_tags
        run: |
          # Pobierz wersjƒô
          VERSION="${{ steps.version.outputs.VERSION }}"
          
          # ZastƒÖp znak + na - w wersji dla tagu Dockera
          DOCKER_VERSION="${VERSION//+/-}"
          echo "Docker tag version: $DOCKER_VERSION"
          
          # Zapisz zmiennƒÖ do outputs
          echo "version=$DOCKER_VERSION" >> $GITHUB_OUTPUT

      # Krok 10: Konfiguracja Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Krok 11: Logowanie do GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Krok 12: Budowanie i publikowanie obrazu Docker
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:latest
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Krok 13: Tworzenie tagu Git dla wersji
      - name: Create Git Tag
        run: |
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Pobierz wersjƒô
          VERSION="${{ steps.version.outputs.VERSION }}"
          echo "Tworzenie tagu Git dla wersji: v$VERSION"
          
          # Utw√≥rz tag lokalnie
          git tag -a "v$VERSION" -m "Version $VERSION"
          
          # Wypchnij tag do repozytorium
          git push origin "v$VERSION"
          echo "Tag v$VERSION zosta≈Ç utworzony i wys≈Çany do repozytorium"

      # Krok 14: Tworzenie wydania na GitHubie
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          name: Release v${{ steps.version.outputs.VERSION }}
          body: "${{ steps.changelog.outputs.CHANGELOG }}"
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Krok 15: Podsumowanie wykonania workflow
      - name: Summary
        run: |
          echo "### üì¶ MCServerWatchdog Deployment" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Wersja**: v${{ steps.version.outputs.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "üè∑Ô∏è **Docker tag**: ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "üìÖ **Data wydania**: $(date +'%d.%m.%Y %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
          
          # Dodaj informacjƒô o lintowaniu
          if [[ "${{ steps.lint.outputs.has_errors }}" == "true" ]]; then
            echo "‚ö†Ô∏è **Ostrze≈ºenie**: Wykryto problemy w kodzie podczas lintowania" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **Linting**: Kod przeszed≈Ç wszystkie testy" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Dodaj link do wydania
          echo "üîó **Link do wydania**: [v${{ steps.version.outputs.VERSION }}](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.VERSION }})" >> $GITHUB_STEP_SUMMARY