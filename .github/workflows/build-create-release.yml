name: Build, Test, Release and Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  build-test-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Pobierz pe≈ÇnƒÖ historiƒô dla prawid≈Çowego tagowania

      # Testowanie kodu Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest semver
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Lint with flake8
        run: |
          # Sprawdzenie tylko krytycznych b≈Çƒôd√≥w
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics

      # Mo≈ºna dodaƒá testy, je≈õli je masz
      # - name: Test with pytest
      #   run: |
      #     pytest

      # Generowanie wersji z inkrementacjƒÖ - mo≈ºesz wybraƒá typ przy rƒôcznym uruchomieniu
      - name: Generate version
        id: version
        run: |
          # Sprawd≈∫ typ releasu - domy≈õlnie patch
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          RELEASE_TYPE=${RELEASE_TYPE:-patch}
          echo "Release type: $RELEASE_TYPE"
          
          # Funkcja do parsowania i inkrementacji wersji SemVer
          increment_version() {
            local version=$1
            local type=$2
            
            # Je≈õli wersja nie jest w formacie SemVer, konwertuj jƒÖ
            if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              # Sprawd≈∫ czy istnieje version.txt
              if [ -f "version.txt" ]; then
                # Pr√≥buj odczytaƒá wersjƒô z pliku
                local file_version=$(cat version.txt)
                # Sprawd≈∫ czy to jest SemVer
                if [[ $file_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                  version=$file_version
                else
                  # Domy≈õlna wersja startowa
                  version="1.0.0"
                fi
              else
                # Domy≈õlna wersja startowa
                version="1.0.0"
              fi
            fi
            
            # Podziel wersjƒô na czƒô≈õci
            IFS='.' read -r major minor patch <<< "$version"
            
            # Inkrementuj odpowiedniƒÖ czƒô≈õƒá
            case $type in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
            esac
            
            # Zwr√≥ƒá nowƒÖ wersjƒô
            echo "$major.$minor.$patch"
          }
          
          # Spr√≥buj znale≈∫ƒá ostatni tag wersji
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Usu≈Ñ 'v' z tagu je≈õli istnieje
          if [[ $LAST_TAG == v* ]]; then
            CURRENT_VERSION=${LAST_TAG#v}
          else
            CURRENT_VERSION=$LAST_TAG
          fi
          
          # Inkrementuj wersjƒô
          VERSION=$(increment_version "$CURRENT_VERSION" "$RELEASE_TYPE")
          
          # Je≈õli to automatyczny push do main, dodaj datƒô i hash commita
          if [ "$RELEASE_TYPE" == "" ] || [ "${{ github.event_name }}" == "push" ]; then
            COMMIT_HASH=$(git rev-parse --short HEAD)
            BUILD_DATE=$(date +'%Y%m%d')
            VERSION="${VERSION}+${BUILD_DATE}.${COMMIT_HASH}"
          fi
          
          echo "Poprzednia wersja: $CURRENT_VERSION"
          echo "Nowa wersja: $VERSION"
          
          # Zapisz wersjƒô do pliku
          echo "$VERSION" > version.txt
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      # Przygotowanie opisu zmian (changelog)
      - name: Generate changelog
        id: changelog
        run: |
          # Pobierz commity od ostatniego taga lub poczƒÖtku historii
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            # Je≈õli nie ma tag√≥w, we≈∫ wszystkie commity
            COMMIT_LIST=$(git log --pretty=format:"%h||%an||%s" --reverse | tail -n 20)
          else
            # Je≈õli sƒÖ tagi, we≈∫ commity od ostatniego taga
            COMMIT_LIST=$(git log ${LAST_TAG}..HEAD --pretty=format:"%h||%an||%s" --reverse)
          fi
          
          # Przygotuj mapƒô kategorii zmian
          declare -A CATEGORIES
          CATEGORIES=(
            ["fix"]="üêõ Poprawki b≈Çƒôd√≥w"
            ["feat"]="‚ú® Nowe funkcje"
            ["docs"]="üìö Dokumentacja"
            ["style"]="üíé Formatowanie kodu"
            ["refactor"]="‚ôªÔ∏è Refaktoryzacja"
            ["perf"]="üöÄ Optymalizacja"
            ["test"]="üß™ Testy"
            ["build"]="üîß Build"
            ["ci"]="ü§ñ CI/CD"
            ["chore"]="üßπ PorzƒÖdki"
          )
          
          # Funkcja sprawdzajƒÖca typ commita
          get_commit_type() {
            local commit_msg="$1"
            
            for type in "${!CATEGORIES[@]}"; do
              if [[ "$commit_msg" == "$type"* || "$commit_msg" == *"[$type]"* || "$commit_msg" == *"($type)"* ]]; then
                echo "$type"
                return
              fi
            done
            
            # Domy≈õlnie, je≈õli nie rozpoznano typu
            echo "other"
          }
          
          # Inicjalizacja zmiennych dla kategorii
          for category in "${CATEGORIES[@]}"; do
            eval "${category//:/_}_COMMITS=''"
          done
          OTHER_COMMITS=""
          
          # Przetwarzanie commit√≥w i grupowanie ich
          while IFS= read -r line; do
            IFS='||' read -r hash author message <<< "$line"
            commit_type=$(get_commit_type "$message")
            
            # Usu≈Ñ prefix typu z tre≈õci commita
            clean_message=$(echo "$message" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\([^)]+\))?:\s*//g')
            clean_message=$(echo "$clean_message" | sed -E 's/\[(feat|fix|docs|style|refactor|perf|test|build|ci|chore)\]\s*//g')
            clean_message=$(echo "$clean_message" | sed -E 's/\((feat|fix|docs|style|refactor|perf|test|build|ci|chore)\)\s*//g')
            
            # ≈Åadne formatowanie wpisu changelog
            formatted_entry="* ${clean_message} [${hash}](https://github.com/${{ github.repository }}/commit/${hash})"
            
            # Dodaj do odpowiedniej kategorii
            if [ "$commit_type" != "other" ]; then
              category_var="${CATEGORIES[$commit_type]//:/_}_COMMITS"
              eval "$category_var=\"$formatted_entry\n\${$category_var}\""
            else
              OTHER_COMMITS="${formatted_entry}\n${OTHER_COMMITS}"
            fi
          done <<< "$COMMIT_LIST"
          
          # Przygotowanie ka≈ºdej sekcji
          FINAL_CHANGELOG=""
          
          # Dodaj sekcje tylko je≈õli majƒÖ zawarto≈õƒá
          for type in "${!CATEGORIES[@]}"; do
            category_var="${CATEGORIES[$type]//:/_}_COMMITS"
            eval "commits=\${$category_var}"
            
            if [ -n "$commits" ]; then
              FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${CATEGORIES[$type]}\n${commits}\n\n"
            fi
          done
          
          # Dodaj inne zmiany (je≈õli sƒÖ)
          if [ -n "$OTHER_COMMITS" ]; then
            FINAL_CHANGELOG="${FINAL_CHANGELOG}### üîÑ Inne zmiany\n${OTHER_COMMITS}\n\n"
          fi
          
          # Je≈õli nie ma zmian, dodaj informacjƒô
          if [ -z "$FINAL_CHANGELOG" ]; then
            FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
          fi
          
          # Zapisz changelog do pliku
          echo "# üì¶ MCServerWatchdog v${{ steps.version.outputs.VERSION }}" > changelog.md
          echo "" >> changelog.md
          echo "Data wydania: $(date +'%d.%m.%Y')" >> changelog.md
          echo "" >> changelog.md
          echo -e "## üìã Lista zmian\n" >> changelog.md
          echo -e "$FINAL_CHANGELOG" >> changelog.md
          echo "## üìä Statystyki" >> changelog.md
          echo "- Wersja: ${{ steps.version.outputs.VERSION }}" >> changelog.md
          
          # Liczba commit√≥w
          COMMIT_COUNT=$(echo "$COMMIT_LIST" | wc -l)
          echo "- Liczba commit√≥w: $COMMIT_COUNT" >> changelog.md
          
          # Lista autor√≥w
          AUTHORS=$(echo "$COMMIT_LIST" | cut -d'||' -f2 | sort | uniq | tr '\n' ', ' | sed 's/,$//')
          echo "- Autorzy: $AUTHORS" >> changelog.md
          
          # Escape tekstu dla GitHub Actions
          FINAL_CHANGELOG_ESCAPED=$(cat changelog.md)
          FINAL_CHANGELOG_ESCAPED="${FINAL_CHANGELOG_ESCAPED//'%'/'%25'}"
          FINAL_CHANGELOG_ESCAPED="${FINAL_CHANGELOG_ESCAPED//$'\n'/'%0A'}"
          FINAL_CHANGELOG_ESCAPED="${FINAL_CHANGELOG_ESCAPED//$'\r'/'%0D'}"
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo "$FINAL_CHANGELOG_ESCAPED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Budowanie i publikowanie obrazu Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:latest
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.version.outputs.VERSION }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Tworzenie taga git dla wersji
      - name: Create Git Tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a v${{ steps.version.outputs.VERSION }} -m "Version ${{ steps.version.outputs.VERSION }}"
          git push origin v${{ steps.version.outputs.VERSION }}

      # Tworzenie releasu na GitHubie
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          name: Release v${{ steps.version.outputs.VERSION }}
          body: "${{ steps.changelog.outputs.CHANGELOG }}"
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}