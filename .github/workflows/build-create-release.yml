name: Build, Test, Release and Deploy

permissions:
  contents: write  # Daje uprawnienia do pushowania zmian do repozytorium
  packages: write  # Potrzebne do publikowania obraz√≥w Docker

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  build-test-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Pobierz pe≈ÇnƒÖ historiƒô dla prawid≈Çowego tagowania

      # Testowanie kodu Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest semver
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Lint with flake8
        run: |
          # Sprawdzenie tylko krytycznych b≈Çƒôd√≥w
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics

      # Mo≈ºna dodaƒá testy, je≈õli je masz
      # - name: Test with pytest
      #   run: |
      #     pytest

      # Generowanie wersji z inkrementacjƒÖ - mo≈ºesz wybraƒá typ przy rƒôcznym uruchomieniu
      - name: Generate version
        id: version
        run: |
          # Sprawd≈∫ typ releasu - domy≈õlnie patch
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          RELEASE_TYPE=${RELEASE_TYPE:-patch}
          echo "Release type: $RELEASE_TYPE"
          
          # Funkcja do parsowania i inkrementacji wersji SemVer
          increment_version() {
            local version=$1
            local type=$2
            
            # Je≈õli wersja nie jest w formacie SemVer, konwertuj jƒÖ
            if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              # Sprawd≈∫ czy istnieje version.txt
              if [ -f "version.txt" ]; then
                # Pr√≥buj odczytaƒá wersjƒô z pliku
                local file_version=$(cat version.txt)
                # Sprawd≈∫ czy to jest SemVer
                if [[ $file_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                  version=$file_version
                else
                  # Domy≈õlna wersja startowa
                  version="1.0.0"
                fi
              else
                # Domy≈õlna wersja startowa
                version="1.0.0"
              fi
            fi
            
            # Podziel wersjƒô na czƒô≈õci
            IFS='.' read -r major minor patch <<< "$version"
            
            # Inkrementuj odpowiedniƒÖ czƒô≈õƒá
            case $type in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
            esac
            
            # Zwr√≥ƒá nowƒÖ wersjƒô
            echo "$major.$minor.$patch"
          }
          
          # Spr√≥buj znale≈∫ƒá ostatni tag wersji
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Usu≈Ñ 'v' z tagu je≈õli istnieje
          if [[ $LAST_TAG == v* ]]; then
            CURRENT_VERSION=${LAST_TAG#v}
          else
            CURRENT_VERSION=$LAST_TAG
          fi
          
          # Inkrementuj wersjƒô
          VERSION=$(increment_version "$CURRENT_VERSION" "$RELEASE_TYPE")
          
          # Je≈õli to automatyczny push do main, dodaj datƒô i hash commita
          if [ "$RELEASE_TYPE" == "" ] || [ "${{ github.event_name }}" == "push" ]; then
            COMMIT_HASH=$(git rev-parse --short HEAD)
            BUILD_DATE=$(date +'%Y%m%d')
            VERSION="${VERSION}+${BUILD_DATE}.${COMMIT_HASH}"
          fi
          
          echo "Poprzednia wersja: $CURRENT_VERSION"
          echo "Nowa wersja: $VERSION"
          
          # Zapisz wersjƒô do pliku
          echo "$VERSION" > version.txt
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Commit version file
        run: |
          # Konfiguracja Git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Sprawd≈∫, czy plik version.txt zosta≈Ç zmieniony
          if [[ -n "$(git status --porcelain version.txt)" ]]; then
            echo "Plik version.txt zosta≈Ç zmieniony, tworzƒô commit..."
            
            # Dodaj plik version.txt do stage
            git add version.txt
            
            # Utw√≥rz commit
            git commit -m "Aktualizacja version.txt do wersji ${{ steps.version.outputs.VERSION }}"
            
            # Wypchnij zmiany do repozytorium
            # Uwaga: token GITHUB_TOKEN musi mieƒá uprawnienia do pushowania
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
            
            echo "Zaktualizowano plik version.txt w repozytorium"
          else
            echo "Plik version.txt nie uleg≈Ç zmianie, pomijam commit"
          fi

      # Przygotowanie opisu zmian (changelog)
      - name: Generate changelog
        id: changelog
        run: |
          # Pobierz commity od ostatniego taga lub poczƒÖtku historii
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            # Je≈õli nie ma tag√≥w, we≈∫ wszystkie commity
            COMMIT_LIST=$(git log --pretty=format:"%h||%an||%s" --reverse | tail -n 20)
          else
            # Je≈õli sƒÖ tagi, we≈∫ commity od ostatniego taga
            COMMIT_LIST=$(git log ${LAST_TAG}..HEAD --pretty=format:"%h||%an||%s" --reverse)
          fi
          
          # Przygotuj mapƒô kategorii zmian - u≈ºywamy zwyk≈Çych identyfikator√≥w jako kluczy
          declare -A CATEGORIES
          CATEGORIES=(
            ["fix"]="Poprawki b≈Çƒôd√≥w"
            ["feat"]="Nowe funkcje"
            ["docs"]="Dokumentacja"
            ["style"]="Formatowanie kodu"
            ["refactor"]="Refaktoryzacja"
            ["perf"]="Optymalizacja"
            ["test"]="Testy"
            ["build"]="Build"
            ["ci"]="CI/CD"
            ["chore"]="PorzƒÖdki"
          )
          
          # Mapa emoji dla ka≈ºdej kategorii - u≈ºywana tylko do wy≈õwietlania
          declare -A CATEGORY_EMOJIS
          CATEGORY_EMOJIS=(
            ["fix"]="üêõ"
            ["feat"]="‚ú®"
            ["docs"]="üìö"
            ["style"]="üíé"
            ["refactor"]="‚ôªÔ∏è"
            ["perf"]="üöÄ"
            ["test"]="üß™"
            ["build"]="üîß"
            ["ci"]="ü§ñ"
            ["chore"]="üßπ"
            ["other"]="üîÑ"
          )
          
          # Funkcja sprawdzajƒÖca typ commita
          get_commit_type() {
            local commit_msg="$1"
            
            for type in "${!CATEGORIES[@]}"; do
              if [[ "$commit_msg" == "$type"* || "$commit_msg" == *"[$type]"* || "$commit_msg" == *"($type)"* ]]; then
                echo "$type"
                return
              fi
            done
            
            # Domy≈õlnie, je≈õli nie rozpoznano typu
            echo "other"
          }
          
          # Inicjalizacja zmiennych dla ka≈ºdej kategorii
          # U≈ºywamy bezpiecznych identyfikator√≥w
          for type in "${!CATEGORIES[@]}"; do
            eval "${type}_commits=''"
          done
          other_commits=""
          
          # Przetwarzanie commit√≥w i grupowanie ich
          while IFS= read -r line; do
            if [ -z "$line" ]; then
              continue
            fi
            
            IFS='||' read -r hash author message <<< "$line"
            commit_type=$(get_commit_type "$message")
            
            # Usu≈Ñ prefix typu z tre≈õci commita
            clean_message=$(echo "$message" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\([^)]+\))?:\s*//g')
            clean_message=$(echo "$clean_message" | sed -E 's/\[(feat|fix|docs|style|refactor|perf|test|build|ci|chore)\]\s*//g')
            clean_message=$(echo "$clean_message" | sed -E 's/\((feat|fix|docs|style|refactor|perf|test|build|ci|chore)\)\s*//g')
            
            # ≈Åadne formatowanie wpisu changelog
            formatted_entry="* ${clean_message} [${hash}](https://github.com/${{ github.repository }}/commit/${hash})"
            
            # Dodaj do odpowiedniej kategorii
            if [ "$commit_type" != "other" ]; then
              # U≈ºywamy zmiennej z bezpiecznƒÖ nazwƒÖ
              eval "${commit_type}_commits=\"${formatted_entry}\n\${${commit_type}_commits}\""
            else
              other_commits="${formatted_entry}\n${other_commits}"
            fi
          done <<< "$COMMIT_LIST"
          
          # Przygotowanie ka≈ºdej sekcji
          FINAL_CHANGELOG=""
          
          # Dodaj sekcje tylko je≈õli majƒÖ zawarto≈õƒá
          for type in "${!CATEGORIES[@]}"; do
            # Pobierz zawarto≈õƒá z bezpiecznej zmiennej
            eval "commits=\${${type}_commits}"
            
            if [ -n "$commits" ]; then
              emoji="${CATEGORY_EMOJIS[$type]}"
              category_name="${CATEGORIES[$type]}"
              FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} ${category_name}\n${commits}\n\n"
            fi
          done
          
          # Dodaj inne zmiany (je≈õli sƒÖ)
          if [ -n "$other_commits" ]; then
            emoji="${CATEGORY_EMOJIS[other]}"
            FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} Inne zmiany\n${other_commits}\n\n"
          fi
          
          # Je≈õli nie ma zmian, dodaj informacjƒô
          if [ -z "$FINAL_CHANGELOG" ]; then
            FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
          fi
          
          # Zapisz changelog do pliku
          echo "# üì¶ MCServerWatchdog v${{ steps.version.outputs.VERSION }}" > changelog.md
          echo "" >> changelog.md
          echo "Data wydania: $(date +'%d.%m.%Y')" >> changelog.md
          echo "" >> changelog.md
          echo -e "## üìã Lista zmian\n" >> changelog.md
          echo -e "$FINAL_CHANGELOG" >> changelog.md
          echo "## üìä Statystyki" >> changelog.md
          echo "- Wersja: ${{ steps.version.outputs.VERSION }}" >> changelog.md
          
          # Liczba commit√≥w
          COMMIT_COUNT=$(echo "$COMMIT_LIST" | wc -l)
          echo "- Liczba commit√≥w: $COMMIT_COUNT" >> changelog.md
          
          # Lista autor√≥w
          AUTHORS=$(echo "$COMMIT_LIST" | cut -d'||' -f2 | sort | uniq | tr '\n' ', ' | sed 's/,$//')
          echo "- Autorzy: $AUTHORS" >> changelog.md
          
          # U≈ºyj cat z zapisanego pliku
          echo 'CHANGELOG<<EOF' >> $GITHUB_OUTPUT
          cat changelog.md >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

      # Budowanie i publikowanie obrazu Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:latest
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.version.outputs.VERSION }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Tworzenie taga git dla wersji
      - name: Create Git Tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a v${{ steps.version.outputs.VERSION }} -m "Version ${{ steps.version.outputs.VERSION }}"
          git push origin v${{ steps.version.outputs.VERSION }}

      # Tworzenie releasu na GitHubie
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          name: Release v${{ steps.version.outputs.VERSION }}
          body: "${{ steps.changelog.outputs.CHANGELOG }}"
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}