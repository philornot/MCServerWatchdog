name: Build, Test, Release and Deploy

# Konfiguracja uprawnień — niezbędna do aktualizacji repozytorium i publikowania pakietów
permissions:
  contents: write  # Uprawnienia do pushowania zmian i tworzenia release'ów
  packages: write  # Uprawnienia do publikowania obrazów Docker

# Wyzwalacze workflow
on:
  # Uruchamianie ręczne z wyborem typu wersji
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Typ wydania'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch   # Drobne poprawki (zwiększa 0.0.X)
          - minor   # Nowe funkcje (zwiększa 0.X.0)
          - major   # Zmiany łamiące kompatybilność (zwiększa X.0.0)

# Definicja zadań
jobs:
  build-test-release:
    runs-on: ubuntu-latest

    steps:
      # Krok 1: Pobierz kod
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Pobierz pełną historię (potrzebne dla tagów i historii commitów)

      # Krok 2: Wykryj nazwę bieżącej gałęzi i zapisz ją jako zmienną
      - name: Get current branch
        id: branch
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "Current branch name: $BRANCH_NAME"
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      # Krok 3: Konfiguracja Pythona
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Krok 4: Instalacja zależności
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest semver
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # Krok 5: Lintowanie kodu (sprawdzanie błędów składniowych)
      - name: Lint with flake8
        id: lint
        continue-on-error: true  # Nie zatrzymuj workflow w przypadku błędów lintowania
        run: |
          # Sprawdzenie tylko krytycznych błędów
          LINT_OUTPUT=$(flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics)
          
          # Zapisz czy wystąpiły błędy
          if [ -n "$LINT_OUTPUT" ]; then
            echo "::warning::$LINT_OUTPUT"
            echo "Znaleziono problemy w kodzie, sprawdź szczegóły w logach"
            echo "has_errors=true" >> $GITHUB_OUTPUT
          else
            echo "Analiza kodu przebiegła pomyślnie"
            echo "has_errors=false" >> $GITHUB_OUTPUT
          fi

      # Krok 6: Generowanie i walidacja wersji
      - name: Generate and Validate Version
        id: version
        run: |
          # Funkcja zwracająca skrócony hash aktualnego commita
          get_short_hash() {
            git rev-parse --short HEAD
          }

          # Funkcja inkrementująca wersję zgodnie z regułami SemVer
          increment_version() {
            local version="$1"
            local type="$2"

            # Wyodrębnij bazową wersję (bez hasha)
            version_base="${version%%+*}"

            # Sprawdź czy format wersji jest poprawny
            if [[ ! $version_base =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              echo "::warning::Niepoprawny format wersji '$version_base'. Ustawiam domyślną wersję 1.0.0" >&2
              version_base="1.0.0"
            fi

            # Rozdziel wersję na składowe (major.minor.patch)
            local IFS='.'
            read -r major minor patch <<< "$version_base"
            
            # Jeśli patch jest pusty, ustaw go na 0
            patch=${patch:-0}
            
            # Inkrementuj odpowiednią część wersji według typu wydania
            case "$type" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
              *)
                echo "::warning::Nieznany typ wydania '$type'. Używam 'patch'" >&2
                patch=$((patch + 1))
                ;;
            esac

            # Zwróć nową wersję
            echo "$major.$minor.$patch"
          }

          # Pobierz typ wydania z parametrów
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          RELEASE_TYPE=${RELEASE_TYPE:-patch}
          echo "Typ wydania: $RELEASE_TYPE"

          # Sprawdź, czy istnieje plik version.txt i pobierz aktualną wersję
          if [ -f "version.txt" ]; then
            VERSION=$(cat version.txt | tr -d '[:space:]')
            echo "Aktualna wersja: $VERSION"

            # Inkrementuj wersję bazową tylko jeśli plik istnieje
            BASE_VERSION=$(increment_version "$VERSION" "$RELEASE_TYPE")
            echo "Bazowa wersja po inkrementacji: $BASE_VERSION"
          else
            # Jeśli plik nie istnieje, użyj wersji 1.0.0 bez inkrementacji
            BASE_VERSION="1.0.0"
            echo "Nie znaleziono pliku version.txt, używam wersji początkowej: $BASE_VERSION"
          fi

          # Dla wydania typu patch dodaj hash commita
          if [[ "$RELEASE_TYPE" == "patch" ]]; then
            SHORT_HASH=$(get_short_hash)
            NEW_VERSION="${BASE_VERSION}+${SHORT_HASH}"
            echo "Dodano hash commita: $SHORT_HASH"
          else
            NEW_VERSION="$BASE_VERSION"
          fi

          # Zwaliduj format nowej wersji
          if [[ ! "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\+[a-zA-Z0-9]+)?$ ]]; then
            echo "::error::Błąd: Wygenerowana wersja '$NEW_VERSION' jest nieprawidłowa."
            exit 1
          fi

          # Zapisz nową wersję do pliku version.txt
          echo "$NEW_VERSION" > version.txt
          
          # Ustaw zmienną wyjściową dla kolejnych kroków
          echo "clean_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Wygenerowana wersja: $NEW_VERSION"

      # Krok 7: Commitowanie zmian w pliku version.txt
      - name: Commit version file
        id: commit
        run: |
          # Pobierz nazwę bieżącej gałęzi z poprzedniego kroku
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          echo "Bieżąca gałąź: $BRANCH_NAME"
          
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Sprawdź, czy plik version.txt został zmieniony
          if [[ -n "$(git status --porcelain version.txt)" ]]; then
            echo "Plik version.txt został zmieniony, tworzę commit..."
          
            # Dodaj plik version.txt do stage
            git add version.txt
          
            # Utwórz commit
            git commit -m "Aktualizacja version.txt do wersji ${{ steps.version.outputs.clean_version }}"
          
            # Wypchnij zmiany do repozytorium
            echo "Wypychanie zmian do gałęzi $BRANCH_NAME..."
            git push origin HEAD:${BRANCH_NAME}
          
            echo "Zaktualizowano plik version.txt w repozytorium"
            echo "committed=true" >> $GITHUB_OUTPUT
          else
            echo "Plik version.txt nie uległ zmianie, pomijam commit"
            echo "committed=false" >> $GITHUB_OUTPUT
          fi

      # Krok 8: Generowanie changelog
      - name: Generate changelog
        id: changelog
        run: |
          set -x  # Włącz tryb debug, aby zobaczyć wykonywane polecenia
          
          # Użyj odpowiedniego punktu odniesienia do wyszukiwania commitów
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            echo "Poprzedni commit zawierał aktualizację version.txt, uwzględniam w changelog"
            # Użyj HEAD~1 jako bazy, aby uwzględnić ostatni commit aktualizujący wersję
            GIT_REF_BASE="HEAD~1"
          else
            echo "Poprzedni commit nie zawierał aktualizacji version.txt"
            GIT_REF_BASE="HEAD"
          fi
          
          # Pobierz commity od ostatniego taga lub początku historii
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "Nie znaleziono tagów, pobieram wszystkie commity (maksymalnie 20)"
            # Jeśli nie ma tagów, weź wszystkie commity (ale ogranicz do 20)
            COMMIT_LIST=$(git log --pretty=format:"%h||%an||%s" --reverse | tail -n 20)
          else
            echo "Znaleziono tag $LAST_TAG, pobieram commity od tego tagu"
            # Jeśli są tagi, weź commity od ostatniego taga
            COMMIT_LIST=$(git log ${LAST_TAG}..${GIT_REF_BASE} --pretty=format:"%h||%an||%s" --reverse)
          fi
          
          # Sprawdź czy mamy jakiekolwiek commity do przetworzenia
          if [ -z "$COMMIT_LIST" ]; then
            echo "UWAGA: Nie znaleziono żadnych commitów do przetworzenia"
            COMMIT_LIST="dummy||bot||dummy commit, aby zapewnić poprawne działanie skryptu"
          fi
          
          # Przygotuj mapę kategorii zmian
          declare -A CATEGORIES
          CATEGORIES=(
            ["fix"]="Poprawki błędów"
            ["feat"]="Nowe funkcje"
            ["docs"]="Dokumentacja"
            ["style"]="Formatowanie kodu"
            ["refactor"]="Refaktoryzacja"
            ["perf"]="Optymalizacja"
            ["test"]="Testy"
            ["build"]="Build"
            ["ci"]="CI/CD"
            ["chore"]="Porządki"
          )
          
          # Mapa emoji dla każdej kategorii
          declare -A CATEGORY_EMOJIS
          CATEGORY_EMOJIS=(
            ["fix"]="🐛"
            ["feat"]="✨"
            ["docs"]="📚"
            ["style"]="💎"
            ["refactor"]="♻️"
            ["perf"]="🚀"
            ["test"]="🧪"
            ["build"]="🔧"
            ["ci"]="🤖"
            ["chore"]="🧹"
            ["other"]="🔄"
          )
          
          # Funkcja sprawdzająca typ commita
          get_commit_type() {
            local commit_msg="$1"
          
            for type in "${!CATEGORIES[@]}"; do
              if [[ "$commit_msg" == "$type"* || "$commit_msg" == *"[$type]"* || "$commit_msg" == *"($type)"* ]]; then
                echo "$type"
                return
              fi
            done
          
            # Domyślnie, jeśli nie rozpoznano typu
            echo "other"
          }
          
          # Inicjalizacja zmiennych dla każdej kategorii
          for type in "${!CATEGORIES[@]}"; do
            declare "${type}_commits=''"
          done
          other_commits=""
          
          # Przetwarzanie commitów i grupowanie ich
          while IFS= read -r line; do
            if [ -z "$line" ]; then
              continue
            fi
          
            # Parsuj linię na hash, autora i wiadomość
            IFS='||' read -r hash author message <<< "$line"
          
            if [ -z "$hash" ] || [ -z "$message" ]; then
              echo "Pominięto niewłaściwy format commita: $line"
              continue
            fi
          
            # Określ typ commita
            commit_type=$(get_commit_type "$message")
          
            # Usuń prefix typu z treści commita
            clean_message=$(echo "$message" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\([^)]+\))?:\s*//g' | sed -E 's/\[(feat|fix|docs|style|refactor|perf|test|build|ci|chore)\]\s*//g' | sed -E 's/\((feat|fix|docs|style|refactor|perf|test|build|ci|chore)\)\s*//g')
          
            # Zabezpiecz tekst przed specjalnymi znakami
            clean_message=$(echo "$clean_message" | sed 's/"/\\"/g')
          
            # Ładne formatowanie wpisu changelog z linkiem do commita
            formatted_entry="* ${clean_message} [${hash}](https://github.com/${{ github.repository }}/commit/${hash})"
          
            # Dodaj do odpowiedniej kategorii
            if [ "$commit_type" != "other" ]; then
              # Używamy eval aby przypisać wartość do zmiennej o nazwie z ${commit_type}_commits
              eval "${commit_type}_commits=\"\${${commit_type}_commits}\n${formatted_entry}\""
            else
              other_commits="${other_commits}\n${formatted_entry}"
            fi
          done <<< "$COMMIT_LIST"
          
          # Przygotowanie każdej sekcji
          FINAL_CHANGELOG=""
          
          # Dodaj sekcje tylko jeśli mają rzeczywistą zawartość
          for type in "${!CATEGORIES[@]}"; do
            # Pobierz zawartość z dynamicznej zmiennej
            content_var="${type}_commits"
            commits=$(eval "echo \"\${$content_var}\"")
            
            # Wyczyść puste linie i sprawdź, czy sekcja ma zawartość
            cleaned_commits=$(echo "$commits" | grep -v "^$" | grep -v "^''$" || echo "")
            
            if [ -n "$cleaned_commits" ]; then
              emoji="${CATEGORY_EMOJIS[$type]}"
              category_name="${CATEGORIES[$type]}"
              FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} ${category_name}\n${cleaned_commits}\n\n"
            fi
          done
          
          # Dodaj inne zmiany (jeśli są)
          cleaned_other_commits=$(echo "$other_commits" | grep -v "^$" | grep -v "^''$" || echo "")
          if [ -n "$cleaned_other_commits" ]; then
            emoji="${CATEGORY_EMOJIS[other]}"
            FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} Inne zmiany${cleaned_other_commits}\n\n"
          fi
          
          # Jeśli nie ma zmian, dodaj informację
          if [ -z "$FINAL_CHANGELOG" ]; then
            FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
          fi
          
          # Zapisz changelog do pliku
          echo "# 📦 MCServerWatchdog v${{ steps.version.outputs.clean_version }}" > changelog.md
          echo "" >> changelog.md
          echo "Data wydania: $(date +'%d.%m.%Y')" >> changelog.md
          echo "" >> changelog.md
          echo -e "## 📋 Lista zmian\n" >> changelog.md
          echo -e "$FINAL_CHANGELOG" >> changelog.md
          echo "## 📊 Statystyki" >> changelog.md
          echo "- Wersja: ${{ steps.version.outputs.clean_version }}" >> changelog.md
          
          # Liczba commitów
          if [ -n "$COMMIT_LIST" ] && [ "$COMMIT_LIST" != "dummy||bot||dummy commit, aby zapewnić poprawne działanie skryptu" ]; then
            COMMIT_COUNT=$(echo "$COMMIT_LIST" | wc -l)
            echo "- Liczba commitów: $COMMIT_COUNT" >> changelog.md
          
            # Lista autorów
            AUTHORS=$(echo "$COMMIT_LIST" | cut -d'||' -f2 | sort | uniq | tr '\n' ', ' | sed 's/,\s*$//')
            if [ -n "$AUTHORS" ] && [ "$AUTHORS" != "Nieznani" ] && [ "$AUTHORS" != "GitHub Action" ] && [ "$AUTHORS" != "GitHub Actions" ] && [ "$AUTHORS" != "bot" ]; then
              echo "- Autorzy: $AUTHORS" >> changelog.md
            else
              # Spróbuj pobrać dane autora z git config lub użyj właściciela repozytorium
              REPO_OWNER="${{ github.repository_owner }}"
              GIT_AUTHOR=$(git config --get user.name || echo "$REPO_OWNER")
              echo "- Autorzy: $GIT_AUTHOR" >> changelog.md
            fi
          else
            echo "- Liczba commitów: 0" >> changelog.md
            echo "- Autorzy: ${{ github.repository_owner }}" >> changelog.md
          fi
          
          # Zapisz changelog jako output
          # Użyj bezpieczniejszego podejścia do zapisywania multi-line output
          echo "CHANGELOG<<CHANGELOGEOF" >> $GITHUB_OUTPUT
          cat changelog.md >> $GITHUB_OUTPUT
          echo "CHANGELOGEOF" >> $GITHUB_OUTPUT

      # Krok 9: Przygotowanie tagów Docker (zastąpienie + na -)
      - name: Prepare Docker tags
        id: docker_tags
        run: |
          # Pobierz wersję
          VERSION="${{ steps.version.outputs.clean_version }}"
          
          # Zastąp znak + na - w wersji dla tagu Dockera
          DOCKER_VERSION="${VERSION//+/-}"
          echo "Docker tag version: $DOCKER_VERSION"
          
          # Zapisz zmienną do outputs
          echo "version=$DOCKER_VERSION" >> $GITHUB_OUTPUT

      # Krok 10: Konfiguracja Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Krok 11: Logowanie do GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Krok 12: Budowanie i publikowanie obrazu Docker
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:latest
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Krok 13: Tworzenie tagu Git dla wersji
      - name: Create Git Tag
        run: |
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Pobierz wersję
          VERSION="${{ steps.version.outputs.clean_version }}"
          echo "Tworzenie tagu Git dla wersji: v$VERSION"
          
          # Sprawdź, czy tag już istnieje (unikaj błędów)
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "::warning::Tag v$VERSION już istnieje, pomijam tworzenie tagu"
          else
            # Utwórz tag lokalnie
            git tag -a "v$VERSION" -m "Version $VERSION"
            
            # Wypchnij tag do repozytorium
            git push origin "v$VERSION"
            echo "Tag v$VERSION został utworzony i wysłany do repozytorium"
          fi

      # Krok 14: Tworzenie wydania na GitHubie
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.clean_version }}
          name: Release v${{ steps.version.outputs.clean_version }}
          body: "${{ steps.changelog.outputs.CHANGELOG }}"
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Krok 15: Podsumowanie wykonania workflow
      - name: Summary
        run: |
          echo "### 📦 MCServerWatchdog Deployment" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Wersja**: v${{ steps.version.outputs.clean_version }}" >> $GITHUB_STEP_SUMMARY
          echo "🏷️ **Docker tag**: ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "📅 **Data wydania**: $(date +'%d.%m.%Y %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
          
          # Dodaj informację o lintowaniu
          if [[ "${{ steps.lint.outputs.has_errors }}" == "true" ]]; then
            echo "⚠️ **Ostrzeżenie**: Wykryto problemy w kodzie podczas lintowania" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **Linting**: Kod przeszedł wszystkie testy" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Dodaj link do wydania
          echo "🔗 **Link do wydania**: [v${{ steps.version.outputs.clean_version }}](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.clean_version }})" >> $GITHUB_STEP_SUMMARY