name: Build, Test, Release and Deploy

# Konfiguracja uprawnie≈Ñ ‚Äî niezbƒôdna do aktualizacji repozytorium i publikowania pakiet√≥w
permissions:
  contents: write  # Uprawnienia do pushowania zmian i tworzenia release'√≥w
  packages: write  # Uprawnienia do publikowania obraz√≥w Docker

# Wyzwalacze workflow
on:
  # Uruchamianie rƒôczne z wyborem typu wersji
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Typ wydania'
        required: true
        default: 'patch'
        type: choice
        options:
          - prerelease  # Wydanie testowe (dodaje tylko hash, bez inkrementacji)
          - patch       # Drobne poprawki (zwiƒôksza 0.0.X)
          - minor       # Nowe funkcje (zwiƒôksza 0.X.0)
          - major       # Zmiany ≈ÇamiƒÖce kompatybilno≈õƒá (zwiƒôksza X.0.0)

# Definicja zada≈Ñ
jobs:
  build-test-release:
    runs-on: ubuntu-latest

    steps:
      # Krok 1: Pobierz kod
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Pobierz pe≈ÇnƒÖ historiƒô (potrzebne dla tag√≥w i historii commit√≥w)

      # Krok 2: Wykryj nazwƒô bie≈ºƒÖcej ga≈Çƒôzi i zapisz jƒÖ jako zmiennƒÖ
      - name: Get current branch
        id: branch
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "Current branch name: $BRANCH_NAME"
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      # Krok 3: Konfiguracja Pythona
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Krok 4: Instalacja zale≈ºno≈õci
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest semver
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # Krok 5: Lintowanie kodu (sprawdzanie b≈Çƒôd√≥w sk≈Çadniowych)
      - name: Lint with flake8
        id: lint
        continue-on-error: true  # Nie zatrzymuj workflow w przypadku b≈Çƒôd√≥w lintowania
        run: |
          # Sprawdzenie tylko krytycznych b≈Çƒôd√≥w
          LINT_OUTPUT=$(flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics)
          
          # Zapisz czy wystƒÖpi≈Çy b≈Çƒôdy
          if [ -n "$LINT_OUTPUT" ]; then
            echo "::warning::$LINT_OUTPUT"
            echo "Znaleziono problemy w kodzie, sprawd≈∫ szczeg√≥≈Çy w logach"
            echo "has_errors=true" >> $GITHUB_OUTPUT
          else
            echo "Analiza kodu przebieg≈Ça pomy≈õlnie"
            echo "has_errors=false" >> $GITHUB_OUTPUT
          fi

      # Krok 6: Generowanie i walidacja wersji z poprawionƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w
      - name: Generate and Validate Version
        id: version
        run: |
          set -e  # Zako≈Ñcz w przypadku b≈Çƒôdu
          
          # Funkcja zwracajƒÖca skr√≥cony hash aktualnego commita
          get_short_hash() {
            git rev-parse --short HEAD
          }
          
          # Funkcja inkrementujƒÖca wersjƒô zgodnie z regu≈Çami SemVer
          increment_version() {
            local version="$1"
            local type="$2"
          
            echo "Debug: Inkrementacja wersji $version, typ: $type" >&2
          
            # Wyodrƒôbnij bazowƒÖ wersjƒô (bez hasha)
            version_base="${version%%+*}"
            echo "Debug: Bazowa wersja (bez hasha): $version_base" >&2
          
            # Sprawd≈∫ czy format wersji jest poprawny
            if [[ ! $version_base =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              echo "::warning::Niepoprawny format wersji '$version_base'. Ustawiam domy≈õlnƒÖ wersjƒô 1.0.0" >&2
              version_base="1.0.0"
            fi
          
            # Rozdziel wersjƒô na sk≈Çadowe (major.minor.patch)
            local IFS='.'
            read -r major minor patch <<< "$version_base"
          
            # Je≈õli patch jest pusty, ustaw go na 0
            patch=${patch:-0}
          
            echo "Debug: Sk≈Çadowe wersji: major=$major, minor=$minor, patch=$patch" >&2
          
            # Inkrementuj odpowiedniƒÖ czƒô≈õƒá wersji wed≈Çug typu wydania
            case "$type" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
              prerelease)
                # Dla wydania prerelease nie inkrementujemy numer√≥w
                ;;
              *)
                echo "::warning::Nieznany typ wydania '$type'. U≈ºywam 'patch'" >&2
                patch=$((patch + 1))
                ;;
            esac
          
            # Zwr√≥ƒá nowƒÖ wersjƒô
            echo "$major.$minor.$patch"
          }
          
          # Pobierz typ wydania z parametr√≥w
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          RELEASE_TYPE=${RELEASE_TYPE:-patch}
          echo "Typ wydania: $RELEASE_TYPE"
          
          # Walidacja typu wydania
          if [[ ! "$RELEASE_TYPE" =~ ^(prerelease|patch|minor|major)$ ]]; then
            echo "::warning::Nieprawid≈Çowy typ wydania '$RELEASE_TYPE'. U≈ºywam domy≈õlnego 'patch'."
            RELEASE_TYPE="patch"
          fi
          
          # Sprawd≈∫, czy istnieje plik version.txt i pobierz aktualnƒÖ wersjƒô
          if [ -f "version.txt" ]; then
            VERSION=$(cat version.txt | tr -d '[:space:]')
            echo "Debug: Odczytana wersja z pliku: '$VERSION'"
          
            # Dodatkowa walidacja formatu wersji w pliku
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\+[a-zA-Z0-9]+)?$ ]]; then
              echo "::warning::Nieprawid≈Çowy format wersji w version.txt: '$VERSION', resetujƒô do 1.0.0"
              VERSION="1.0.0"
            fi
          
            echo "Aktualna wersja: $VERSION"
          
            # Inkrementuj wersjƒô bazowƒÖ tylko je≈õli plik istnieje
            BASE_VERSION=$(increment_version "$VERSION" "$RELEASE_TYPE")
            echo "Bazowa wersja po inkrementacji: $BASE_VERSION"
          else
            # Je≈õli plik nie istnieje, u≈ºyj wersji 1.0.0 bez inkrementacji
            BASE_VERSION="1.0.0"
            echo "Nie znaleziono pliku version.txt, u≈ºywam wersji poczƒÖtkowej: $BASE_VERSION"
          fi
          
          # Tylko dla wydania prerelease dodaj hash commita
          SHORT_HASH=$(get_short_hash)
          if [[ "$RELEASE_TYPE" == "prerelease" ]]; then
            NEW_VERSION="${BASE_VERSION}+${SHORT_HASH}"
            echo "Dodano hash commita dla prerelease: $SHORT_HASH"
          else
            NEW_VERSION="$BASE_VERSION"
          fi
          
          # Debugowanie wygenerowanej wersji
          echo "Debug: Wygenerowana wersja: '$NEW_VERSION'"
          
          # Zwaliduj format nowej wersji
          if [[ ! "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\+[a-zA-Z0-9]+)?$ ]]; then
            echo "::error::B≈ÇƒÖd: Wygenerowana wersja '$NEW_VERSION' jest nieprawid≈Çowa."
            echo "Debug: Sk≈Çadowe:"
            echo "- BASE_VERSION: $BASE_VERSION"
            echo "- RELEASE_TYPE: $RELEASE_TYPE" 
            echo "- SHORT_HASH: $SHORT_HASH"
            exit 1
          fi
          
          # Zapisz nowƒÖ wersjƒô do pliku version.txt
          echo "$NEW_VERSION" > version.txt
          echo "Debug: Zapisana wersja w pliku:"
          cat version.txt
          
          # Ustaw zmienne wyj≈õciowe dla kolejnych krok√≥w
          echo "clean_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$([[ "$RELEASE_TYPE" == "prerelease" ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "Wygenerowana wersja: $NEW_VERSION (prerelease: $([[ "$RELEASE_TYPE" == "prerelease" ]] && echo "tak" || echo "nie"))"

      # Krok 7: Commitowanie zmian w pliku version.txt (z obs≈ÇugƒÖ konflikt√≥w)
      - name: Commit version file
        id: commit
        run: |
          # Pobierz nazwƒô bie≈ºƒÖcej ga≈Çƒôzi z poprzedniego kroku
          BRANCH_NAME="${{ steps.branch.outputs.name }}"
          echo "Bie≈ºƒÖca ga≈ÇƒÖ≈∫: $BRANCH_NAME"
          
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Sprawd≈∫, czy plik version.txt zosta≈Ç zmieniony
          if [[ -n "$(git status --porcelain version.txt)" ]]; then
            echo "Plik version.txt zosta≈Ç zmieniony, tworzƒô commit..."
          
            # Dodaj plik version.txt do stage
            git add version.txt
          
            # Utw√≥rz commit
            git commit -m "Aktualizacja version.txt do wersji ${{ steps.version.outputs.clean_version }}"
          
            # Pr√≥ba push z obs≈ÇugƒÖ konflikt√≥w
            echo "Pr√≥ba push zmian do ga≈Çƒôzi $BRANCH_NAME..."
          
            # Najpierw pobierz najnowsze zmiany z remote, zachowujƒÖc lokalny commit
            git fetch origin $BRANCH_NAME
          
            # Opcja 1: Pr√≥ba rebase (preferowana, zachowuje historiƒô liniowƒÖ)
            if git rebase origin/$BRANCH_NAME; then
              echo "Rebase zako≈Ñczony pomy≈õlnie, wykonujƒô push..."
              git push origin HEAD:${BRANCH_NAME}
            else
              # Opcja 2: Anuluj rebase i spr√≥buj merge
              git rebase --abort
              echo "Rebase nie powi√≥d≈Ç siƒô, pr√≥bujƒô merge..."
          
              if git pull --no-rebase origin $BRANCH_NAME && git push origin HEAD:${BRANCH_NAME}; then
                echo "Merge i push zako≈Ñczone pomy≈õlnie"
              else
                # Opcja 3: W skrajnym przypadku, gdy wszystko inne zawiedzie, u≈ºyj force push
                echo "UWAGA: Standardowy push nie powi√≥d≈Ç siƒô, u≈ºywam force push jako ostatniej opcji"
                if git push --force origin HEAD:${BRANCH_NAME}; then
                  echo "Force push zako≈Ñczony pomy≈õlnie"
                else
                  echo "Force push r√≥wnie≈º siƒô nie powi√≥d≈Ç. Anulowanie."
                  exit 1
                fi
              fi
            fi
          
            echo "Zaktualizowano plik version.txt w repozytorium"
            echo "committed=true" >> $GITHUB_OUTPUT
          else
            echo "Plik version.txt nie uleg≈Ç zmianie, pomijam commit"
            echo "committed=false" >> $GITHUB_OUTPUT
          fi

      # Krok 8: Generowanie changelog z poprawionƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w
      - name: Generate changelog
        id: changelog
        run: |
          set -e  # Zako≈Ñcz w przypadku b≈Çƒôdu
          
          # Dodatkowe debugowanie
          echo "Debug: Uruchamianie kroku generowania changelog"
          
          # U≈ºyj odpowiedniego punktu odniesienia do wyszukiwania commit√≥w
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            echo "Poprzedni commit zawiera≈Ç aktualizacjƒô version.txt, uwzglƒôdniam w changelog"
            # U≈ºyj HEAD~1 jako bazy, aby uwzglƒôdniƒá ostatni commit aktualizujƒÖcy wersjƒô
            GIT_REF_BASE="HEAD~1"
          else
            echo "Poprzedni commit nie zawiera≈Ç aktualizacji version.txt"
            GIT_REF_BASE="HEAD"
          fi
          
          # Pobierz commity od ostatniego taga lub poczƒÖtku historii
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "Nie znaleziono tag√≥w, pobieram wszystkie commity (maksymalnie 20)"
            # Je≈õli nie ma tag√≥w, we≈∫ wszystkie commity z zabezpieczeniem przed pustƒÖ listƒÖ
            COMMIT_LIST=$(git log --pretty=format:"%h||%an||%s" --reverse 2>/dev/null || echo "")
            if [ -n "$COMMIT_LIST" ]; then
              COMMIT_LIST=$(echo "$COMMIT_LIST" | tail -n 20)
            fi
          else
            echo "Znaleziono tag $LAST_TAG, pobieram commity od tego tagu"
            # Je≈õli sƒÖ tagi, we≈∫ commity od ostatniego taga
            COMMIT_LIST=$(git log ${LAST_TAG}..${GIT_REF_BASE} --pretty=format:"%h||%an||%s" --reverse 2>/dev/null || echo "")
          fi
          
          # Debug - poka≈º listƒô commit√≥w
          echo "Debug: Lista commit√≥w do przetworzenia:"
          echo "$COMMIT_LIST" | head -n 5
          echo "..."
          
          # Sprawdzamy, czy lista jest pusta
          if [ -z "$COMMIT_LIST" ]; then
            echo "Nie znaleziono ≈ºadnych commit√≥w do przetworzenia."
            FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
          else
            echo "Znaleziono commity, przetwarzam..."
          
            # Przygotuj kategorie jako zwyk≈Çe tablice zamiast asocjacyjnych (dla kompatybilno≈õci)
            CATEGORY_TYPES=("fix" "feat" "docs" "style" "refactor" "perf" "test" "build" "ci" "chore")
            CATEGORY_NAMES=("Poprawki b≈Çƒôd√≥w" "Nowe funkcje" "Dokumentacja" "Formatowanie kodu" "Refaktoryzacja" "Optymalizacja" "Testy" "Build" "CI/CD" "PorzƒÖdki")
            CATEGORY_EMOJIS=("üêõ" "‚ú®" "üìö" "üíé" "‚ôªÔ∏è" "üöÄ" "üß™" "üîß" "ü§ñ" "üßπ")
          
            # Inicjalizacja zmiennych dla kategorii
            fix_commits=""
            feat_commits=""
            docs_commits=""
            style_commits=""
            refactor_commits=""
            perf_commits=""
            test_commits=""
            build_commits=""
            ci_commits=""
            chore_commits=""
            other_commits=""
          
            # Przetwarzanie commit√≥w - zapisujemy najpierw do pliku tymczasowego
            echo "$COMMIT_LIST" > /tmp/commits.txt
          
            # Przetwarzanie linii po linii z zabezpieczeniem
            while IFS= read -r line; do
              if [ -z "$line" ]; then
                continue
              fi
          
              # Parsowanie linii na hash, autora i wiadomo≈õƒá (z obs≈ÇugƒÖ b≈Çƒôd√≥w)
              hash=$(echo "$line" | cut -d'|' -f1 || echo "")
              author=$(echo "$line" | cut -d'|' -f3 || echo "Unknown")
              message=$(echo "$line" | cut -d'|' -f5- || echo "")
          
              if [ -z "$hash" ] || [ -z "$message" ]; then
                echo "Debug: Pomijam nieprawid≈Çowy format: $line"
                continue
              fi
          
              # Uproszczone okre≈õlanie typu commita
              commit_type="other"
              for type in "${CATEGORY_TYPES[@]}"; do
                if [[ "$message" == "$type"* || "$message" == *"[$type]"* || "$message" == *"($type)"* ]]; then
                  commit_type="$type"
                  break
                fi
              done
          
              # Oczyszczenie wiadomo≈õci commita (uproszczone)
              clean_message=$(echo "$message" | sed 's/^.*://' | sed 's/^\s*//')
              if [ -z "$clean_message" ]; then
                clean_message="$message"
              fi
          
              # Formatowanie wpisu
              formatted_entry="* ${clean_message} [${hash}](https://github.com/${{ github.repository }}/commit/${hash})"
          
              # Przypisanie do odpowiedniej kategorii
              case "$commit_type" in
                "fix") fix_commits="${fix_commits}${formatted_entry}\n" ;;
                "feat") feat_commits="${feat_commits}${formatted_entry}\n" ;;
                "docs") docs_commits="${docs_commits}${formatted_entry}\n" ;;
                "style") style_commits="${style_commits}${formatted_entry}\n" ;;
                "refactor") refactor_commits="${refactor_commits}${formatted_entry}\n" ;;
                "perf") perf_commits="${perf_commits}${formatted_entry}\n" ;;
                "test") test_commits="${test_commits}${formatted_entry}\n" ;;
                "build") build_commits="${build_commits}${formatted_entry}\n" ;;
                "ci") ci_commits="${ci_commits}${formatted_entry}\n" ;;
                "chore") chore_commits="${chore_commits}${formatted_entry}\n" ;;
                *) other_commits="${other_commits}${formatted_entry}\n" ;;
              esac
            done < /tmp/commits.txt
          
            # Przygotowanie changeloga
            FINAL_CHANGELOG=""
          
            # Dodawanie sekcji dla ka≈ºdej kategorii
            for i in "${!CATEGORY_TYPES[@]}"; do
              type="${CATEGORY_TYPES[$i]}"
              name="${CATEGORY_NAMES[$i]}"
              emoji="${CATEGORY_EMOJIS[$i]}"
          
              # Pobierz zawarto≈õƒá odpowiedniej zmiennej
              case "$type" in
                "fix") commits="$fix_commits" ;;
                "feat") commits="$feat_commits" ;;
                "docs") commits="$docs_commits" ;;
                "style") commits="$style_commits" ;;
                "refactor") commits="$refactor_commits" ;;
                "perf") commits="$perf_commits" ;;
                "test") commits="$test_commits" ;;
                "build") commits="$build_commits" ;;
                "ci") commits="$ci_commits" ;;
                "chore") commits="$chore_commits" ;;
                *) commits="" ;;
              esac
          
              # Dodaj sekcjƒô je≈õli sƒÖ jakie≈õ commity
              if [ -n "$commits" ]; then
                FINAL_CHANGELOG="${FINAL_CHANGELOG}### ${emoji} ${name}\n${commits}\n"
              fi
            done
          
            # Dodaj inne zmiany
            if [ -n "$other_commits" ]; then
              FINAL_CHANGELOG="${FINAL_CHANGELOG}### üîÑ Inne zmiany\n${other_commits}\n"
            fi
          
            # Je≈õli nie ma zmian, dodaj informacjƒô
            if [ -z "$FINAL_CHANGELOG" ]; then
              FINAL_CHANGELOG="Brak zmian od ostatniego wydania."
            fi
          fi
          
          # Dodaj informacjƒô o paczce instalacyjnej ZIP
          INSTALL_INFO="\n## üì• Instalacja/Aktualizacja\n\nDla u≈Çatwienia instalacji/aktualizacji, do≈ÇƒÖczono paczkƒô instalacyjnƒÖ `mcserverwatchdog-v${{ steps.version.outputs.clean_version }}.zip`, kt√≥ra zawiera wszystkie niezbƒôdne pliki do uruchomienia bota (main.py, pretty_logger.py, version.txt).\n\n**Jak zaktualizowaƒá bota na serwerze:**\n\n1. Pobierz plik ZIP z tej strony\n2. Rozpakuj pliki do katalogu bota na serwerze (nadpisujƒÖc istniejƒÖce pliki)\n3. Upewnij siƒô, ≈ºe plik .env jest skonfigurowany poprawnie\n4. Uruchom ponownie bota\n\nPlik .env nie jest do≈ÇƒÖczony do paczki i musisz go skonfigurowaƒá samodzielnie.\n"
          
          # Dodaj informacjƒô o prerelease
          if [[ "${{ steps.version.outputs.is_prerelease }}" == "true" ]]; then
            echo "‚ö†Ô∏è **PRERELEASE**: Ta wersja jest oznaczona jako wydanie wstƒôpne" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Zapisz changelog do pliku
          echo "# üì¶ MCServerWatchdog v${{ steps.version.outputs.clean_version }}" > changelog.md
          echo "" >> changelog.md
          echo "Data wydania: $(date +'%d.%m.%Y')" >> changelog.md
          echo "" >> changelog.md
          echo -e "## üìã Lista zmian\n" >> changelog.md
          echo -e "$FINAL_CHANGELOG" >> changelog.md
          echo -e "$INSTALL_INFO" >> changelog.md
          echo "## üìä Statystyki" >> changelog.md
          echo "- Wersja: ${{ steps.version.outputs.clean_version }}" >> changelog.md
          
          # Dodaj statystyki
          if [ -n "$COMMIT_LIST" ]; then
            COMMIT_COUNT=$(echo "$COMMIT_LIST" | wc -l)
            echo "- Liczba commit√≥w: $COMMIT_COUNT" >> changelog.md
          
            # Uproszczona obs≈Çuga autor√≥w
            REPO_OWNER="${{ github.repository_owner }}"
            echo "- Autorzy: $REPO_OWNER" >> changelog.md
          else
            echo "- Liczba commit√≥w: 0" >> changelog.md
            echo "- Autorzy: Brak nowych commit√≥w" >> changelog.md
          fi
          
          # Debug: Poka≈º zawarto≈õƒá changeloga
          echo "Debug: Wygenerowany changelog:"
          cat changelog.md
          
          # Zapisz changelog jako output
          echo 'CHANGELOG<<EOF' >> $GITHUB_OUTPUT
          cat changelog.md >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

      # Krok 9: Przygotowanie tag√≥w Docker (zastƒÖpienie + na -)
      - name: Prepare Docker tags
        id: docker_tags
        run: |
          # Pobierz wersjƒô
          VERSION="${{ steps.version.outputs.clean_version }}"
          
          # ZastƒÖp znak + na - w wersji dla tagu Dockera
          DOCKER_VERSION="${VERSION//+/-}"
          echo "Docker tag version: $DOCKER_VERSION"
          
          # Zapisz zmiennƒÖ do outputs
          echo "version=$DOCKER_VERSION" >> $GITHUB_OUTPUT

      # Krok 10: Konfiguracja Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Krok 11: Logowanie do GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Krok 12: Budowanie i publikowanie obrazu Docker
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:latest
            ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Krok 13: Przygotowanie paczki instalacyjnej ZIP
      - name: Create installation package
        id: create_package
        run: |
          set -e  # Zatrzymaj siƒô przy pierwszym b≈Çƒôdzie
          
          # Instalacja narzƒôdzia zip
          echo "Instalacja narzƒôdzia zip..."
          sudo apt-get update && sudo apt-get install -y zip
          
          # Weryfikacja instalacji zip
          echo "Sprawdzanie dostƒôpno≈õci narzƒôdzia zip..."
          which zip
          
          # Ustal nazwƒô pliku ZIP
          VERSION="${{ steps.version.outputs.clean_version }}"
          ZIP_FILENAME="mcserverwatchdog-v${VERSION}.zip"
          echo "Tworzenie paczki instalacyjnej: ${ZIP_FILENAME}"
          
          # Przygotuj katalog tymczasowy
          echo "Przygotowanie katalogu tymczasowego..."
          rm -rf temp_package || true
          mkdir -p temp_package
          
          # Lista plik√≥w do skopiowania
          echo "Kopiowanie plik√≥w do paczki..."
          
          # Wymagane pliki - je≈õli kt√≥rykolwiek brakuje, wy≈õwietl ostrze≈ºenie ale kontynuuj
          for file in main.py pretty_logger.py version.txt requirements.txt; do
            if [ -f "$file" ]; then
              echo "Kopiowanie $file..."
              cp "$file" temp_package/ || echo "‚ö†Ô∏è Ostrze≈ºenie: Nie uda≈Ço siƒô skopiowaƒá pliku $file"
            else
              echo "‚ö†Ô∏è Ostrze≈ºenie: Brak pliku $file"
            fi
          done
          
          # Opcjonalne pliki
          if [ -f ".env.example" ]; then
            cp ".env.example" temp_package/ || echo "‚ö†Ô∏è Ostrze≈ºenie: Nie uda≈Ço siƒô skopiowaƒá pliku .env.example"
          fi
          
          # Tworzenie pliku README
          echo "Tworzenie pliku README.txt..."
          cat > temp_package/README.txt << EOF
          MCServerWatchdog v${VERSION}
          ==========================================
          
          Aby uruchomiƒá bota:
          
          1. Upewnij siƒô, ≈ºe masz zainstalowanego Pythona 3.10 lub nowszego
          2. Zainstaluj wymagane biblioteki: pip install -r requirements.txt 
          3. Skopiuj plik .env.example do .env i uzupe≈Çnij wszystkie wymagane dane
          4. Uruchom bota: python main.py
          
          Wiƒôcej informacji znajdziesz na stronie projektu:
          https://github.com/${{ github.repository }}
          EOF
          
          # Sprawdzenie zawarto≈õci katalogu
          echo "Zawarto≈õƒá katalogu temp_package:"
          ls -la temp_package/
          
          # Sprawdzenie czy katalog nie jest pusty
          if [ -z "$(ls -A temp_package/)" ]; then
            echo "::error::Katalog temp_package jest pusty, nie mo≈ºna utworzyƒá paczki"
            exit 1
          fi
          
          # Tworzenie archiwum ZIP
          echo "Tworzenie archiwum ZIP..."
          (cd temp_package && zip -r "../${ZIP_FILENAME}" *)
          
          # Sprawdzenie czy plik ZIP zosta≈Ç utworzony poprawnie
          if [ -f "${ZIP_FILENAME}" ]; then
            echo "‚úÖ Paczka instalacyjna zosta≈Ça utworzona pomy≈õlnie: ${ZIP_FILENAME}"
            ls -lh "${ZIP_FILENAME}"
            echo "filename=${ZIP_FILENAME}" >> $GITHUB_OUTPUT
          else
            echo "::error::Nie uda≈Ço siƒô utworzyƒá paczki instalacyjnej"
            exit 1
          fi

      # Krok 14: Tworzenie tagu Git dla wersji
      - name: Create Git Tag
        if: success() # Wykonuj, tylko je≈õli poprzednie kroki siƒô powiod≈Çy
        run: |
          # Konfiguracja Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Pobierz wersjƒô
          VERSION="${{ steps.version.outputs.clean_version }}"
          echo "Tworzenie tagu Git dla wersji: v$VERSION"
          
          # Sprawd≈∫, czy tag ju≈º istnieje (unikaj b≈Çƒôd√≥w)
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "::warning::Tag v$VERSION ju≈º istnieje, pomijam tworzenie tagu"
          else
            # Utw√≥rz tag lokalnie
            git tag -a "v$VERSION" -m "Version $VERSION"
          
            # Wypchnij tag do repozytorium
            git push origin "v$VERSION"
            echo "Tag v$VERSION zosta≈Ç utworzony i wys≈Çany do repozytorium"
          fi

      # Krok 15: Tworzenie wydania na GitHubie z do≈ÇƒÖczonym ZIP
      - name: Create GitHub Release
        if: success() && steps.create_package.outputs.filename != ''
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.clean_version }}
          name: Release v${{ steps.version.outputs.clean_version }}
          body: "${{ steps.changelog.outputs.CHANGELOG }}"
          draft: false
          prerelease: ${{ steps.version.outputs.is_prerelease }}
          generate_release_notes: false
          files: |
            ${{ steps.create_package.outputs.filename }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Krok 16: Podsumowanie wykonania workflow
      - name: Summary
        if: always()
        run: |
          echo "### üì¶ MCServerWatchdog Deployment" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "‚úÖ **Status**: Sukces" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Wersja**: v${{ steps.version.outputs.clean_version }}" >> $GITHUB_STEP_SUMMARY
            
            # Dodaj informacjƒô o prerelease
            if [[ "${{ steps.version.outputs.is_prerelease }}" == "true" ]]; then
              echo "‚ö†Ô∏è **PRERELEASE**: Ta wersja jest oznaczona jako wydanie wstƒôpne" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "üè∑Ô∏è **Docker tag**: ghcr.io/${{ github.repository_owner }}/mcserverwatchdog:${{ steps.docker_tags.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "üìÖ **Data wydania**: $(date +'%d.%m.%Y %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
            
            if [[ -n "${{ steps.create_package.outputs.filename }}" ]]; then
              echo "üì• **Paczka instalacyjna**: ${{ steps.create_package.outputs.filename }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Paczka instalacyjna**: Nie utworzono" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Dodaj informacjƒô o lintowaniu
            if [[ "${{ steps.lint.outputs.has_errors }}" == "true" ]]; then
              echo "‚ö†Ô∏è **Ostrze≈ºenie**: Wykryto problemy w kodzie podczas lintowania" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ **Linting**: Kod przeszed≈Ç wszystkie testy" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Dodaj link do wydania
            echo "üîó **Link do wydania**: [v${{ steps.version.outputs.clean_version }}](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.clean_version }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status**: Niepowodzenie" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå **Przyczyna**: Proces CI/CD nie zako≈Ñczy≈Ç siƒô pomy≈õlnie" >> $GITHUB_STEP_SUMMARY
          fi